<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>≈ªabka</title>
    <meta name="description" content="≈ªabka">
    <meta name="author" content="Dawid Gustowski">

    <link rel="icon" href="./icon-512.png">
    <link rel="apple-touch-icon" href="./icon-192.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="Dawid">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">

    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#2c3e50">

    <script src="./script.js"></script>
    <style>
        :root {
            --cell-size: 40px;
            --map-width: 9;
        }

        body {
            background-color: #2c3e50;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            touch-action: none; 
        }

        #game-container {
            position: relative;
            width: calc(var(--cell-size) * var(--map-width));
            height: calc(var(--cell-size) * 11); /* 11 rzƒôd√≥w widocznych */
            background-color: #27ae60;
            border: 4px solid #34495e;
            box-shadow: 0 0 25px rgba(0,0,0,0.6);
            overflow: hidden;
        }

        #world-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            transition: transform 0.1s ease-out;
        }

        .row {
            position: absolute;
            height: var(--cell-size);
            width: 100%;
            display: flex;
            align-items: center;
            font-size: 28px;
            left: 0;
        }

        .row.grass { background-color: #27ae60; border-bottom: 1px solid rgba(0,0,0,0.05); }
        .row.road { background-color: #7f8c8d; border-top: 2px dashed #95a5a6; border-bottom: 2px dashed #95a5a6; box-sizing: border-box; }
        .row.water { background-color: #3498db; }

        .moving-object {
            position: absolute;
            text-align: center;
            width: var(--cell-size);
            height: var(--cell-size);
            line-height: var(--cell-size);
            top: 0;
        }
        
        .log-object {
             width: auto;
             white-space: nowrap;
             letter-spacing: -6px;
        }

        #frog {
            position: absolute;
            width: var(--cell-size);
            height: var(--cell-size);
            font-size: 25px;
            text-align: center;
            line-height: var(--cell-size);
            left: 50%;
            /* Pozycja ≈ºaby jest ustawiana dynamicznie w JS, ale bazowo startuje ni≈ºej */
            transform: translate(-50%, 0); 
            z-index: 10;
            text-shadow: 0 2px 5px rgba(0,0,0,0.4);
            transition: top 0.1s;
        }

        #score-display {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 20px;
            font-weight: bold;
            z-index: 20;
            text-shadow: 1px 1px 2px black;
        }

        #game-over-modal {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 30;
        }

        h2 { color: #e74c3c; margin-bottom: 15px; font-size: 32px;}
        .stat-box { font-size: 22px; margin: 8px 0; }
        .highlight { color: #f1c40f; font-weight: bold; }

        button {
            margin-top: 25px;
            padding: 12px 25px;
            font-size: 18px;
            background-color: #2ecc71;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 4px #27ae60;
        }
        button:active { transform: translateY(2px); box-shadow: 0 2px #27ae60; }
        
        .hint { margin-top: 10px; color: #bdc3c7; font-size: 13px; }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="score-display">Wynik: 0</div>
        
        <div id="world-layer"></div>
        <div id="frog">üê∏</div>

        <div id="game-over-modal">
            <h2>Koniec Gry!</h2>
            <div class="stat-box">Wynik: <span id="final-score" class="highlight">0</span></div>
            <div class="stat-box">Rekord: <span id="best-score" class="highlight">0</span></div>
            <button onclick="resetGame()">Nowa Gra üîÑ</button>
        </div>
    </div>
    
    <div class="hint">Spacja lub Dotknij ekranu, aby skoczyƒá</div>

<script>
    let dawid108 = localStorage.getItem("dawid108") || 0;
    // --- Konfiguracja ---
    const CELL_SIZE = 40;
    const MAP_WIDTH_CELLS = 9;
    const VISIBLE_ROWS = 11; 
    const MAP_WIDTH_PX = CELL_SIZE * MAP_WIDTH_CELLS;
    
    // USTAWIENIE POZYCJI ≈ªABKI:
    // 8 = √≥smy rzƒÖd od g√≥ry (liczƒÖc od 0). To sprawia, ≈ºe ≈ºaba jest nisko,
    // a nad niƒÖ widaƒá 8 rzƒôd√≥w przeszk√≥d.
    const FROG_FIXED_ROW_INDEX = 8; 

    const worldLayer = document.getElementById('world-layer');
    const frogElement = document.getElementById('frog');
    const scoreDisplay = document.getElementById('score-display');
    const modal = document.getElementById('game-over-modal');
    const finalScoreEl = document.getElementById('final-score');
    const bestScoreEl = document.getElementById('best-score');

    const CAR_EMOJIS = ['üöó', 'üöï', 'üöô', 'üöå', 'üöö', 'üèéÔ∏è'];
    const LOG_EMOJI_SEGMENT = 'üü´';

    let score = 0;
    let isGameOver = false;
    let difficultyMultiplier = 1.0;
    let rowsData = [];
    let worldOffset = 0;
    let lastTime = 0;
    let animationFrameId;

    // Zmienne do logiki generowania mapy (zapobieganie duplikatom)
    let lastGeneratedType = 'grass';
    let sameTypeCounter = 0;

    // --- Inicjalizacja Gry ---

    function initGame() {
        score = 0;
        isGameOver = false;
        difficultyMultiplier = 1.0;
        worldOffset = 0;
        rowsData = [];
        worldLayer.innerHTML = '';
        worldLayer.style.transform = `translateY(0px)`;
        scoreDisplay.innerText = `Wynik: ${score}`;
        modal.style.display = 'none';
        
        // Reset generatora
        lastGeneratedType = 'grass';
        sameTypeCounter = 0;

        // Ustawienie wizualne ≈ºabki
        frogElement.style.top = `${FROG_FIXED_ROW_INDEX * CELL_SIZE}px`;

        // Generowanie mapy poczƒÖtkowej
        // Generujemy od do≈Çu (bezpieczna strefa) do g√≥ry (przeszkody)
        // Dziƒôki temu logika "lastGeneratedType" dzia≈Ça poprawnie (budujemy ≈õwiat w prz√≥d)
        
        // 1. Bezpieczna strefa na dole i pod ≈ºabƒÖ (indeksy 2, 1, 0)
        // Indeksy w d√≥≈Ç sƒÖ dodatnie (za ≈ºabƒÖ), w g√≥rƒô ujemne (przed ≈ºabƒÖ)
        for (let i = 2; i >= -10; i--) { 
            generateRow(i, i >= -1); // Force safe dla rzƒôdu -1, 0, 1, 2
        }

        lastTime = performance.now();
        gameLoop(lastTime);
    }

    // --- Logika Generowania Rzƒôd√≥w ---

    function generateRow(rowIndex, forceSafe = false) {
        const rowDiv = document.createElement('div');
        rowDiv.classList.add('row');
        // Pozycja Y: rowIndex 0 to pozycja startowa ≈ºaby.
        // Dodajemy FROG_FIXED_ROW_INDEX, aby przesunƒÖƒá wszystko w d√≥≈Ç ekranu
        rowDiv.style.top = `${(rowIndex + FROG_FIXED_ROW_INDEX) * CELL_SIZE}px`;

        let rowType = 'grass';
        
        if (!forceSafe) {
            // Algorytm decyzyjny
            const rand = Math.random();
            let proposedType = 'grass';
            
            if (rand < 0.45) proposedType = 'road';
            else if (rand < 0.8) proposedType = 'water';

            // Zastosowanie ogranicze≈Ñ (Constraints)
            
            // Regu≈Ça 1 i 2: Maksymalnie 2 takie same pasy obok siebie
            if (proposedType === lastGeneratedType) {
                if (sameTypeCounter >= 2) {
                    proposedType = 'grass'; // Limit osiƒÖgniƒôty -> zr√≥b trawƒô
                }
            }
            
            // Regu≈Ça 3: Rzeka i Ulica nie mogƒÖ siƒô stykaƒá
            if (
                (lastGeneratedType === 'road' && proposedType === 'water') ||
                (lastGeneratedType === 'water' && proposedType === 'road')
            ) {
                proposedType = 'grass'; // Separator
            }

            rowType = proposedType;
        }

        // Aktualizacja stanu generatora
        if (rowType === lastGeneratedType) {
            sameTypeCounter++;
        } else {
            sameTypeCounter = 1;
            lastGeneratedType = rowType;
        }

        // Tworzenie element√≥w
        rowDiv.classList.add(rowType);
        let objects = [];
        let speed = 0;
        let direction = 1;

        if (rowType !== 'grass') {
            speed = (0.9 + Math.random() * 1.4) * difficultyMultiplier;
            direction = Math.random() < 0.5 ? -1 : 1;
            
            // Ilo≈õƒá obiekt√≥w
            const objectCount = rowType === 'road' ? Math.floor(Math.random() * 3) + 1 : Math.floor(Math.random() * 2) + 2;

            for (let i = 0; i < objectCount; i++) {
                const objDiv = document.createElement('div');
                objDiv.classList.add('moving-object');
                
                // Rozmieszczenie
                let startX = (i * (MAP_WIDTH_PX / objectCount)) + (Math.random() * 40);
                let width = CELL_SIZE;

                if (rowType === 'road') {
                    objDiv.innerText = CAR_EMOJIS[Math.floor(Math.random() * CAR_EMOJIS.length)];
                } else {
                    objDiv.classList.add('log-object');
                    const logLength = Math.floor(Math.random() * 3) + 2; // 2-4 segmenty
                    objDiv.innerText = LOG_EMOJI_SEGMENT.repeat(logLength);
                    width = logLength * (CELL_SIZE * 0.7); // Dopasowanie hitboxa k≈Çody
                }
                
                rowDiv.appendChild(objDiv);
                objects.push({ element: objDiv, x: startX, width: width });
            }
        }

        // Dodanie do DOM na poczƒÖtku (≈ºeby nowe rzƒôdy by≈Çy "pod spodem" w strukturze, ale wizualnie na g√≥rze)
        // W tym przypadku append jest ok, bo pozycjonujemy absolute
        worldLayer.appendChild(rowDiv);

        const rowData = {
            index: rowIndex,
            element: rowDiv,
            type: rowType,
            objects: objects,
            speed: speed,
            direction: direction
        };

        // Dodajemy do tablicy i sortujemy, ≈ºeby mieƒá porzƒÖdek
        rowsData.push(rowData);
    }

    // --- Pƒôtla Gry ---

    function gameLoop(currentTime) {
        if (isGameOver) return;
        
        const deltaTime = (currentTime - lastTime) / 1000;
        lastTime = currentTime;

        updateObjects(deltaTime);
        checkCollisions();

        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function updateObjects(deltaTime) {
        rowsData.forEach(row => {
            if (row.speed > 0) {
                row.objects.forEach(obj => {
                    obj.x += row.speed * row.direction * deltaTime * 60;

                    // Zapƒôtlanie obiekt√≥w
                    if (row.direction === 1 && obj.x > MAP_WIDTH_PX) {
                        obj.x = -obj.width;
                    } else if (row.direction === -1 && obj.x < -obj.width) {
                        obj.x = MAP_WIDTH_PX;
                    }

                    obj.element.style.left = `${obj.x}px`;
                });
            }
        });
    }

    // --- Sterowanie ---

    function moveForward() {
        if (isGameOver) return;

        score++;
        dawid108++;
        localStorage.setItem("dawid108", dawid108);
        console.log("dawid108:", dawid108);
        scoreDisplay.innerText = `Wynik: ${score}`;
        
        if (score % 10 === 0) difficultyMultiplier += 0.1;

        // Przesuniƒôcie ≈õwiata
        worldOffset += CELL_SIZE;
        worldLayer.style.transform = `translateY(${worldOffset}px)`;

        // Usuwanie starych rzƒôd√≥w (tych co wypad≈Çy do≈Çem)
        // ≈ªaba jest w rzƒôdzie 0 (wirtualnie), a widok ko≈Ñczy siƒô na FROG_FIXED_ROW_INDEX w d√≥≈Ç
        // Je≈õli index rzƒôdu > (aktualny_postƒôp + margines), usuwamy
        const bottomThresholdIndex = VISIBLE_ROWS - FROG_FIXED_ROW_INDEX + 2; 
        
        // Musimy znale≈∫ƒá najni≈ºszy indeks w tablicy (to jest ten na samej g√≥rze mapy)
        // Poniewa≈º rowsData nie jest idealnie posortowana po pushach, znajd≈∫my minIndex
        let minIndex = rowsData[0].index;
        rowsData.forEach(r => { if(r.index < minIndex) minIndex = r.index; });

        // Generujemy nowy rzƒÖd na g√≥rze (o 1 mniejszy ni≈º najmniejszy obecny)
        generateRow(minIndex - 1);

        // Czyszczenie pamiƒôci (opcjonalne, ale dobre dla wydajno≈õci)
        if (rowsData.length > 25) {
             // Usu≈Ñ rzƒôdy kt√≥re sƒÖ bardzo "na dole" (du≈ºe dodatnie indeksy wzglƒôdem ≈ºaby)
             // ≈ªaba jest logicznie na pozycji -score. Rzƒôdy > -score + 10 sƒÖ niewidoczne
             const limit = -score + 10;
             for (let i = rowsData.length - 1; i >= 0; i--) {
                 if (rowsData[i].index > limit) {
                     rowsData[i].element.remove();
                     rowsData.splice(i, 1);
                 }
             }
        }
        
        checkCollisions();
    }

    // --- Kolizje ---

    function checkCollisions() {
        // ≈ªaba znajduje siƒô logicznie w rzƒôdzie o indeksie: -score
        const currentRowIndex = -score;
        const currentRow = rowsData.find(r => r.index === currentRowIndex);

        if (!currentRow || currentRow.type === 'grass') return;

        const frogCenterX = MAP_WIDTH_PX / 2;
        const frogMargin = CELL_SIZE * 0.25; // Trochƒô mniejszy hitbox

        if (currentRow.type === 'road') {
            for (let car of currentRow.objects) {
                if (isOverlapping(frogCenterX, frogMargin, car.x, car.width)) {
                    gameOver("PotrƒÖcenie! üöó");
                    return;
                }
            }
        } 
        else if (currentRow.type === 'water') {
            let onLog = false;
            for (let log of currentRow.objects) {
                if (isOverlapping(frogCenterX, frogMargin, log.x, log.width)) {
                    onLog = true;
                    break;
                }
            }
            if (!onLog) gameOver("Utoniƒôcie! üåä");
        }
    }

    function isOverlapping(frogCenter, frogMargin, objX, objWidth) {
        const frogLeft = frogCenter - frogMargin;
        const frogRight = frogCenter + frogMargin;
        const objRight = objX + objWidth;
        return (frogLeft < objRight && frogRight > objX);
    }

    function gameOver(reason) {
        isGameOver = true;
        cancelAnimationFrame(animationFrameId);
        
        const savedRecord = localStorage.getItem('zabka');
        let record = savedRecord ? parseInt(savedRecord) : 0;
        if (score > record) {
            record = score;
            localStorage.setItem('zabka', record);
        }

        finalScoreEl.innerText = score;
        bestScoreEl.innerText = record;
        modal.style.display = 'flex';
    }

    function resetGame() {
        initGame();
    }

    // Obs≈Çuga wej≈õcia
    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && !isGameOver) {
            e.preventDefault();
            moveForward();
        }
    });

    document.addEventListener('touchstart', (e) => {
        if (e.target.tagName !== 'BUTTON' && !isGameOver) {
            e.preventDefault();
            moveForward();
        }
    }, {passive: false});
    
    document.addEventListener('mousedown', (e) => {
        if (e.target.tagName !== 'BUTTON' && !isGameOver) {
            e.preventDefault();
            moveForward();
        }
    });

    initGame();

</script>
</body>
</html>
